#!/usr/bin/env bash

dna-check_dns_record() {

	### This function verifies DNS "address" records [A/AAAA]. For other types of checks see other functions below.

	############################################################################

	: '

	Name:

		Must be a DNS name [e.g. ae.os.vu]

	Type:

		Must be either:

			a
			aaaa
			srv

	Reference:

		Must be either:

			1] A string with a comma-separated list of values [no spaces] [e.g.: "1.1.1.1,2.2.2.2,4.4.4.4,8.8.8.8"]
			2] An absolute path to a file with a newline-separated list of IPs

		An individual value can be "null" to indicate that the record must NOT be set at all.

	# '

	############################################################################

	if [ $# -eq 0 ]
    then
        dna-echo -m "${r-}No argument supplied for function | ${FUNCNAME[0]} |."
        dna-exit
    fi

    while getopts ":n:t:r:" arguments; do
        case $arguments in
            n)	name="$OPTARG"
	            ;;
			t)	type="$OPTARG"
	            ;;
			r)	reference="$OPTARG"
	            ;;
            \?)	dna-echo -m "${r-}Invalid option | -$OPTARG | for function | ${FUNCNAME[0]} |."
	            dna-exit
	            ;;
        esac
    done
    OPTIND=1

    if [ -z "${name-}" ]
    then
        dna-echo -m "${r-}Name [option | -n |] must be supplied for function | ${FUNCNAME[0]} |."
        dna-exit
    fi

	if [ -z "${type-}" ]
    then
        dna-echo -m "${r-}Type [option | -t |] must be supplied for function | ${FUNCNAME[0]} |."
        dna-exit
    fi

	if [ -z "${reference-}" ]
    then
        dna-echo -m "${r-}Reference [option | -r |] must be supplied for function | ${FUNCNAME[0]} |."
        dna-exit
    fi

	############################################################################

	dns_checks_dir="/tmp/dns_checks"
	name_file_path="${dns_checks_dir}/${type}-${name}"

	mkdir -p "${dns_checks_dir}"

	############################################################################

	### Check supplied reference type

	reference_leading_char="$(echo ${reference} | cut -c1-1)"

	if [ $reference_leading_char = "/" ]
	then
		reference_type=file
	else
		reference_type=array
	fi

	if [ $reference_type = "file" ]
	then
		reference_file_path="${reference}"
	else
		### Write specified array to a text file
		reference_file_path="${dns_checks_dir}/reference"
		echo "${reference}" | tr "," "\n" > "${reference_file_path}"
	fi

	if ! grep -q '[^[:space:]]' "${reference_file_path}"
	then
		dna-echo -m "${r-}Reference file is empty."
        dna-exit
	fi

	### Check for a "null" reference

	if grep -q "null" "${reference_file_path}"
	then
		### Mark the record as to be removed
		remove_record=y
		### Actually clear the contents of the reference file
		> "${reference_file_path}"
	fi

	### Read array out of $reference_file_path

	readarray -t reference_array < "${reference_file_path}"

	############################################################################

	if [ "${type}" = "a" ]
	then
		version=4
	elif [ "${type}" = "aaaa" ]
	then
		version=6
	fi

	############################################################################

	### Validate all reference items if record type is an address [A / AAAA]

	if [ ! -z "${version-}" ]
	then
		for reference_item in "${reference_array[@]}"
		do
			dna-validate_ipv"${version}" -s -i "${reference_item}"
			if [ "${ip_is_valid}" = "n" ]
			then
				dna-echo -m "${r-}The reference value | ${n-}${reference_item}${r-} | is not a valid | ${n-}IPv${version-}${r-} | address."
				dna-exit
			fi
		done
		unset reference_item
	fi

	############################################################################

	### Convert $type to uppercase for printed messages

	type_name="$(echo ${type} | awk '{print toupper($0)}')"

	############################################################################

	lookup_name(){

		if [ ! -z "${version-}" ]
		then

			host -t "${type}" "${name}" | sed -n -e 's/^.*address //p' > "${name_file_path}"

		elif [ "${type}" = "srv" ]
		then

			host -t srv "${name}" | sed -n -e 's/^.*has SRV record //p' > "${name_file_path}"

		fi

		readarray -t name_array < "${name_file_path}"

	}

	array_contains() {
	    local array="$1[@]"
	    local seeking="$2"
	    local in=1
	    for element in "${!array-null}"
		do
	        if [[ "$element" == "$seeking" ]]
			then
	            in=0
	            break
	        fi
	    done
	    return $in
	}

	############################################################################

	if [ ! "${remove_record-null}" = "y" ]
	then

		### Check that every item in reference_array is contained in name_array

		for reference_item in "${reference_array[@]}"
		do

			until [ "${accept-null}" = "y" ]
			do

				reference_item_name="$(echo ${reference_item} | xargs)"

				lookup_name

				result=$(array_contains name_array "${reference_item}" && echo y || echo n)

		        if [ "${result}" = "y" ]
		        then

		            dna-echo -m "${g-}The | ${n-}${type_name}${g-} | record | ${n-}${reference_item_name}${g-} | for DNS name | ${n-}${name}${g-} | is registered correctly."

					outcome="ok"
					accept="y"

		        else

					incorrect_iteration=$(( ${incorrect_iteration-} + 1 ))

					if [ "${incorrect_iteration}" = "1" ]
					then

						dna-echo -m "${r-}The | ${n-}${type_name}${r-} | record | ${n-}${reference_item_name}${r-} | for DNS name | ${n-}${name}${r-} | is NOT registered."

						if [ "${autoset_dns-null}" = "y" ]
						then

							dna-echo -m "Automatically setting this record on your DNS provider."
							outcome="autofix"
							dna-set_dns_record [...]

						else

							dna-echo -m "You must now set this record on the authoritative DNS provider for this zone."

							if [ "${dns_provider_setup-null}" = "y" ]
							then
								ask_for_boolean_question="Would you like to automatically set this record on [one of] your previously specified DNS provider[s]?"
					            dna-ask_for_boolean_def_yes
					            if [ "$ask_for_boolean_output" = "y" ]
					            then
									dna-echo -m "Ok, automatically setting this DNS record."
									outcome="autofix"
									dna-set_dns_record [...]
								else
									read -rp "${b-}Ok, press enter after you've manually set the record and are ready to continue.${x-}"
									echo
									outcome="manualfix"
								fi
							else
								read -rp "${b-}Press enter after you've set the record and are ready to continue...${x-}"
								echo
								outcome="manualfix"
							fi

						fi

					elif [ "${incorrect_iteration}" -le "4" ]
					then

						dna-echo -m "${r-}The | ${n-}${type_name}${r-} | record | ${n-}${reference_item_name}${r-} | for DNS name | ${n-}${name}${r-} | still appears NOT to be registered."

						if [ "${outcome}" = "manualfix" ]
						then
							dna-echo -m "As we wait to ensure DNS propagation, ensure you've correctly set the record on your DNS provider."
						fi

						wait="$[${incorrect_iteration}**2]"
						tput sc
						while [ "${wait}" -ge "0" ]
						do
						    case $((wait % 4)) in
						        0 ) j="-" ;;
						        1 ) j="/" ;;
						        2 ) j="|" ;;
						        3 ) j="\\" ;;
						    esac
						    tput rc
						    echo -en "\\r${b-}| ${o-}${j}${n-} | Now waiting ${y-}${wait}${n-} more seconds to allow for DNS propagation...${x-}"
						    sleep 1
						    ((wait=wait-1)) || true
						done
						echo
						echo

					else

						dna-echo -m "${r-}The | ${n-}${type_name}${r-} | record | ${n-}${reference_item_name}${r-} | for DNS name | ${n-}${name}${r-} | still appears NOT to be registered after several lookups."
						dna-echo -m "his could be due to longer than normal TTLs on your DNS records [therefore making propagation longer] or an incorrect setting on your DNS provider."
						dna-echo -m "Also ensure you're applying the correct setting to the authoritative DNS provider for this zone."

						until [ "${valid-null}" = "y" ]
						do

							read -n 1 -rp "${b-}Perform DNS check again from the beginning?${x-} (${b-}Y${x-}[es]/${b-}s${x-}[kip]/${b-}e${x-}[xit]) " answer;
							case $answer in
								"")	echo
									valid=y
									accept=n
									;;
								y)	echo -e "\\n"
									valid=y
									accept=n
									;;
								s)	echo -e "\\n"
									dna-echo -m "Ok, skipping DNS check for this record..."
									valid=y
									accept=y
									;;
								e)	echo -e "\\n"
									dna-echo -m "Exiting..."
									exit
									;;
								*)	echo -e "\\n"
									dna-echo -m "${r-}Invalid option. Try again..."
									valid=n
									accept=n
									;;
							esac

						done

						unset incorrect_iteration outcome valid

					fi

				fi

			done

			unset incorrect_iteration outcome valid accept

		done

	fi

	############################################################################

	### Check if name_array has additional incorrect values

	calculate_extra_diff() {

	if [ -n "${name_array-}" ]
	then

		diff_array=()
		for name_item in "${name_array[@]}"
		do
		     skip=
		     for reference_item in "${reference_array[@]}"
			 do
		         [[ $name_item == $reference_item ]] && { skip=1; break; }
		     done
		     [[ -n $skip ]] || diff_array+=("$name_item")
		done
		declare -p diff_array &> /dev/null

	else

		unset diff_array

	fi

	}

	lookup_name

	calculate_extra_diff

	if [ -n "${diff_array-}" ]
	then

		for diff_item in "${diff_array[@]}"
		do

			diff_item_name="$(echo ${diff_item} | xargs)"

			until [ "${accept-null}" = "y" ]
			do

				### Check to see if this extra item is still actually erroneously registered on DNS

				lookup_name

				calculate_extra_diff

				result=$(array_contains diff_array "${diff_item}" && echo y || echo n)

				if [ "${result}" = "n" ]
		        then

					dna-echo -m "${g-}The | ${n-}${type_name}${g-} | record | ${n-}${diff_item_name}${g-} | for DNS name | ${n-}${name}${g-} | has been correctly removed."

					outcome="ok"
					accept="y"

				else

					incorrect_iteration=$(( ${incorrect_iteration-} + 1 ))

					if [ "${incorrect_iteration}" = "1" ]
					then

						dna-echo -m "${r-}The | ${n-}${type_name}${r-} | record | ${n-}${diff_item_name}${r-} | for DNS name | ${n-}${name}${r-} | is registered but should NOT be."

						if [ "${autoset_dns-null}" = "y" ]
						then

							dna-echo -m "Automatically removing this record on your DNS provider."
							outcome="autofix"
							dna-set_dns_record [...]

						else

							dna-echo -m "You must now remove this record on the authoritative DNS provider for this zone."

							if [ "${dns_provider_setup-null}" = "y" ]
							then
								ask_for_boolean_question="Would you like to automatically remove this record on [one of] your previously specified DNS provider[s]?"
					            dna-ask_for_boolean_def_yes
					            if [ "$ask_for_boolean_output" = "y" ]
					            then
									dna-echo -m "Ok, automatically removing this DNS record."
									outcome="autofix"
									dna-set_dns_record [...]
								else
									read -rp "${b-}Ok, press enter after you've manually removed the record and are ready to continue...${x-}"
									echo
									outcome="manualfix"
								fi
							else
								read -rp "${b-}Press enter after you've removed the record and are ready to continue...${x-}"
								echo
								outcome="manualfix"
							fi

						fi

					elif [ "${incorrect_iteration}" -le "4" ]
					then

						dna-echo -m "${r-}The | ${n-}${type_name}${r-} | record | ${n-}${diff_item_name}${r-} | for DNS name | ${n-}${name}${r-} | still appears to be registered even though it should NOT be."

						if [ "${outcome}" = "manualfix" ]
						then
							dna-echo -m "As we wait to ensure DNS propagation, ensure you've correctly removed the record on your DNS provider."
						fi

						wait="$[${incorrect_iteration}**3]"
						tput sc
						while [ "${wait}" -ge "0" ]
						do
						    case $((wait % 4)) in
						        0 ) j="-" ;;
						        1 ) j="/" ;;
						        2 ) j="|" ;;
						        3 ) j="\\" ;;
						    esac
						    tput rc
						    echo -en "\\r${b-}| ${o-}${j}${n-} | Now waiting ${y-}${wait}${n-} more seconds to allow for DNS propagation...${x-}"
						    sleep 1
						    ((wait=wait-1)) || true
						done
						echo
						echo

					else

						dna-echo -m "${r-}The | ${n-}${type_name}${r-} | record | ${n-}${diff_item_name}${r-} | for DNS name | ${n-}${name}${r-} | still appears to be registered after several lookups even though it should NOT be."
						dna-echo -m "This could be due to longer than normal TTLs on your DNS records [therefore making propagation longer] or an incorrect setting on your DNS provider."
						dna-echo -m "Also ensure you're removing the record from the authoritative DNS provider for this zone."

						until [ "${valid-null}" = "y" ]
						do

							read -n 1 -rp "${b-}Perform DNS check again from the beginning?${x-} (${b-}Y${x-}[es]/${b-}s${x-}[kip]/${b-}e${x-}[xit]) " answer;
							case $answer in
								"")	echo
									valid=y
									accept=n
									;;
								y)	echo -e "\\n"
									valid=y
									accept=n
									;;
								s)	echo -e "\\n"
									dna-echo -m "Ok, skipping DNS check for this record..."
									valid=y
									accept=y
									;;
								e)	echo -e "\\n"
									dna-echo -m "Exiting..."
									exit
									;;
								*)	echo -e "\\n"
									dna-echo -m "Invalid option. Try again..."
									valid=n
									accept=n
									;;
							esac

						done

						unset incorrect_iteration outcome valid

					fi

				fi

			done

			unset incorrect_iteration outcome valid accept

		done

	fi

	dna-echo -m "${g-}All | ${n-}${type_name}${g-} | DNS checks for name | ${n-}${name}${g-} | completed successfully."

	rm -rf "${dns_checks_dir}"

	unset name type version reference

}
